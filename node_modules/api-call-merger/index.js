'use strict';
var API = function( ) {

	/*
		A little notice:
		As I understood from the example of final usage (in Google Docs)
		"GET api/resources ? users=api/users & customer=api/customers/23 & countries=api/countries ..
			returns {users: [..], customer: {..}, countries: [..] } 
		"

		Params "users=" , "countries=" and  "customer=" are only desirable name of fields in result object.
		So it's possible to call "api/resources?users=api/countries" and we'll get an 
			object { users : [ <list of countries> ] } with an array of countries. Also if perform a call 
			to "api/resources?rabbit=api/users/id500" API will return { rabbit : {<user's data>} };

		I believe filtering of input to avoid XSS is implemented on API server
	*/

	this.data = {
		httpReq : null,					// Link to HTTP object to perform network requests
		useSecureFunction : false,		// Use function to check user's trustworthy or something else before connect ?
		secureFunction : null, 			// Link to Secure function
		apiRoutes : [ ] ,				// Objects with URLs for APIs
		mainAPIUrl : '',				// First part of URL in request. It's not necessary to use, but in examples you noticed we have final url like "api/resources ? users=api", but not "API2/Resources ? users=api"
		maxUrlParams : 10000			// Max count of params in URL. To avoid unnecessary loading from scammers before they go to blacklist
	};

	this.setSecureOptions = function(useSecureFunction, secureFunction) {
		this.data.useSecureFunction = useSecureFunction;
		this.data.secureFunction = secureFunction;
	};

	this.setMaxUrlParams = function(newCount) {
		this.data.maxUrlParams = newCount;
	};

	this.setMainAPIUrl = function(url) {
		this.data.mainAPIUrl = url;
	};

	this.attachHttpObject = function(httpObject) {
		this.data.httpReq = httpObject;
	};

	this.addAPIRoute = function(apiTemplate, apiURL, isEqual) {
		// apiTemplate - name of api in URL parameter
		// apiURL - url to perform api call
		// isEqual - is apiTemplate is strict or have a changeable part, to hadle api/users and api/user/id177 etc.
		this.data.apiRoutes.push({ apiTemplate : apiTemplate, apiURL : apiURL, isEqual : isEqual});
	};

	this.getDataToExecute = function(requestObject) { // Get an array with groups and urls to execute queries
		// Here in function requestObject is Link to Array - a bit faster than send a string
		var listOfURLParams = requestObject[1].split('&');
		var currentURLParam,currentRoute; // for lower memory consumption and minimize of GC work -  declare vars outside a loop
		var dataToExecute = [ ]; // Here I use an array - it's a way faster than object to iterate and get values;
		var isParamAlreadyInArray = false;
		for ( var i = 0; i < listOfURLParams.length; i++ ) {
			currentURLParam = listOfURLParams[i].split('=');
			if ( currentURLParam.length !== 2 ) continue;
			// Now check this param
			for ( var j = 0; j < this.data.apiRoutes.length; j++ ) {
				currentRoute = this.data.apiRoutes[j];
				if ( currentRoute.isEqual == true ) {
					if ( currentURLParam[1] === currentRoute.apiTemplate ) {
						isParamAlreadyInArray = false;
						// Fastest way to check if duplicate of param is already in array - browse array!
						for ( var k = 0; k < dataToExecute.length; k++ ) {
							if ( dataToExecute[k].group == currentURLParam[0] ) {
								isParamAlreadyInArray = true;
								break;
							}
						}
						if (isParamAlreadyInArray == false && dataToExecute.length < this.data.maxUrlParams) dataToExecute.push({ completed : false, reqId : 'rE'+i, result : null, group : currentURLParam[0], url : currentRoute.apiURL });
					}
				} else {
					if ( currentURLParam[1].indexOf(currentRoute.apiTemplate) === 0 ) {
						isParamAlreadyInArray = false;
						// Fastest way to check if duplicate of param is already in array - browse array!
						for ( var k = 0; k < dataToExecute.length; k++ ) {
							if ( dataToExecute[k].group == currentURLParam[0] ) {
								isParamAlreadyInArray = true;
								break;
							}
						}
						if (isParamAlreadyInArray == false && dataToExecute.length < this.data.maxUrlParams) dataToExecute.push({ completed : false, reqId : 'rNE'+i, result : null, group : currentURLParam[0], url : (currentRoute.apiURL+currentURLParam[1].replace(currentRoute.apiTemplate, '')) });
					}
				}
			};

		};
		return dataToExecute;
	};

	this.parseRequests = function ( inputObject ) { // Parse results. Generate output from internal format
		var resultObject = { };
		var currentCompletedRequest;
		for ( var i = 0; i < inputObject.length; i++ ) {
			currentCompletedRequest = inputObject[i];
			resultObject[currentCompletedRequest.group] = currentCompletedRequest.result;
		}
		return resultObject;
	};

	this.safeApiRequest = function(input, callback, ip) {	// Main funtion of this module - this function initiates execution of all requests
			
		if ( this.data.useSecureFunction === false ) {
			this.apiRequest(input, callback);
		} else {
			var self = this;
			if ( typeof this.data.secureFunction === 'function' && ip != undefined ) {
				this.data.secureFunction(ip, function(data){
					if ( data === true ) {
						self.apiRequest(input, callback);
					} else {
						callback('Please Try Again Later');
					}
				});
			} else {
				callback('Please Try Again Later');
			}
		}
	};

	this.apiRequest = function(input, callback) {	// This function executes after checking user's ip

		// Has callback?
		if ( callback == undefined ) return;

		// Is input string ?
		if ( typeof input !== 'string' ) { callback('InvalidRequest'); return; }

		// Input should like: /api/resources?param1=value1&....
		var inputParams = input.split('?');
		
		if (( inputParams.length === 2 && inputParams[0] === this.data.mainAPIUrl && inputParams[1] != '' ) === false) { callback('InvalidRequest'); return; }

		var possibleQueries = this.getDataToExecute(inputParams);

		var self = this;

		for ( let i = 0; i < possibleQueries.length; i++ ) {
			// Here use a block-scoped let, because it's the easiest way.
			// These let variables are not deep nested, so V8 will optimize it. 
			// Because if let and const variables are deep-nested, previous V8 versions did not optimize 
			// the function with these variables
			this.data.httpReq.get(possibleQueries[i].url, function(res) {
				let body = '';
				res.on('data', function(chunk) {
			    	body += chunk;
			  	});
			 	res.on('end', function() {
			    	possibleQueries[i].completed = true;
			    	possibleQueries[i].result = body;
			    	let allReqCompleted = true;
			    	for ( let j = 0; j < possibleQueries.length; j++ ) {
			    		if ( possibleQueries[j].completed == false ) allReqCompleted = false;
			    	}
			    	if ( allReqCompleted == true ) {
			    		callback(self.parseRequests(possibleQueries));
			    	}
			  	});
			});
		}
	}
};


module.exports = API;